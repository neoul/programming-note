<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Rust - Programming Note</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Rust";
    var mkdocs_page_input_path = "rust.md";
    var mkdocs_page_url = "/rust/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Programming Note</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../algorithm/">Algorithm</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../cpp/">Cpp</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../go/">Go</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../grpc/">Grpc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../javascript/">Javascript</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../python3/">Python3</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Rust</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#rust">Rust</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#why-rust">Why Rust?</a></li>
        
            <li><a class="toctree-l3" href="#roadamp-to-improve">Roadamp to improve</a></li>
        
            <li><a class="toctree-l3" href="#rust_1">Rust íŠ¹ì„±</a></li>
        
            <li><a class="toctree-l3" href="#rust_2">ë‚´ê°€ ìƒê°í•˜ëŠ” rust íŠ¹ì„±</a></li>
        
            <li><a class="toctree-l3" href="#rust-module-system">Rust module system</a></li>
        
            <li><a class="toctree-l3" href="#terms">Terms</a></li>
        
            <li><a class="toctree-l3" href="#latest-version">Latest version</a></li>
        
            <li><a class="toctree-l3" href="#rust-installation">Rust installation</a></li>
        
            <li><a class="toctree-l3" href="#helloworld-with-cargo">Helloworld with cargo</a></li>
        
            <li><a class="toctree-l3" href="#how-to-add-external-crates">How to add external crates</a></li>
        
            <li><a class="toctree-l3" href="#enabling-rust-backtrace">Enabling rust backtrace</a></li>
        
            <li><a class="toctree-l3" href="#rust-macro">Rust macro</a></li>
        
            <li><a class="toctree-l3" href="#prelude-imported-std-libraries">Prelude (imported std libraries)</a></li>
        
            <li><a class="toctree-l3" href="#rust-ownership">Rust ownership (ê°’ì— ëŒ€í•œ ì†Œìœ ê¶Œ)</a></li>
        
            <li><a class="toctree-l3" href="#references-and-borrowing">References and Borrowing</a></li>
        
            <li><a class="toctree-l3" href="#rust-syntax">Rust Syntax</a></li>
        
            <li><a class="toctree-l3" href="#generics">Generics</a></li>
        
            <li><a class="toctree-l3" href="#traits">Traits</a></li>
        
            <li><a class="toctree-l3" href="#to-be-considered">To be considered</a></li>
        
            <li><a class="toctree-l3" href="#collections">collections</a></li>
        
            <li><a class="toctree-l3" href="#useful-code-or-crates">Useful code or crates</a></li>
        
            <li><a class="toctree-l3" href="#modules">Modules</a></li>
        
            <li><a class="toctree-l3" href="#macro">Macro</a></li>
        
            <li><a class="toctree-l3" href="#testing">Testing</a></li>
        
            <li><a class="toctree-l3" href="#rust-attributes">Rust Attributes</a></li>
        
            <li><a class="toctree-l3" href="#keywords">Keywords</a></li>
        
            <li><a class="toctree-l3" href="#good-answer-to-understand">Good answer to understand</a></li>
        
            <li><a class="toctree-l3" href="#associated-items">Associated items</a></li>
        
            <li><a class="toctree-l3" href="#rust-rfc">Rust RFC</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Programming Note</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Rust</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="rust">Rust</h1>
<p>A language empowering everyone to build reliable and efficient software.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ì´ ë¬¸ì„œëŠ” <a href="https://docs.microsoft.com/ko-kr/learn/paths/rust-first-steps">rust-first-steps</a>, <a href="https://www.rust-lang.org">rust-lang.org</a>, <a href="https://doc.rust-lang.org/book/title-page.html">rust-doc</a> ì„ ë³´ê³  ë‚´ìš©ì„ ì •ë¦¬í•œ ë¬¸ì„œì…ë‹ˆë‹¤.</p>
</div>
<ul>
<li><a href="#rust">Rust</a></li>
<li><a href="#why-rust">Why Rust?</a><ul>
<li><a href="#performance">Performance</a></li>
<li><a href="#reliability">Reliability</a></li>
<li><a href="#productivity">Productivity</a></li>
</ul>
</li>
<li><a href="#roadamp-to-improve">Roadamp to improve</a></li>
<li><a href="#rust-íŠ¹ì„±">Rust íŠ¹ì„±</a></li>
<li><a href="#ë‚´ê°€-ìƒê°í•˜ëŠ”-rust-íŠ¹ì„±">ë‚´ê°€ ìƒê°í•˜ëŠ” rust íŠ¹ì„±</a></li>
<li><a href="#rust-module-system">Rust module system</a><ul>
<li><a href="#rust-standard-libary-and-useful-crates">Rust standard libary and useful crates</a></li>
<li><a href="#how-to-use-crates">How to use crates?</a></li>
</ul>
</li>
<li><a href="#terms">Terms</a></li>
<li><a href="#latest-version">Latest version</a></li>
<li><a href="#rust-installation">Rust installation</a><ul>
<li><a href="#cargo">Cargo</a></li>
<li><a href="#cargo-versioning">Cargo versioning</a></li>
<li><a href="#cargotoml-toml-file-for-cargo-config">Cargo.toml (TOML file for cargo config)</a></li>
<li><a href="#cargolock">Cargo.lock</a></li>
<li><a href="#useful-development-tool">Useful development tool</a></li>
<li><a href="#rust-build-tools">Rust build tools</a></li>
<li><a href="#rustup--cargo-command-completion">Rustup &amp; cargo command completion</a></li>
<li><a href="#rust-cookbook">Rust Cookbook</a></li>
</ul>
</li>
<li><a href="#helloworld-with-cargo">Helloworld with cargo</a></li>
<li><a href="#how-to-add-external-crates">How to add external crates</a></li>
<li><a href="#enabling-rust-backtrace">Enabling rust backtrace</a></li>
<li><a href="#rust-macro">Rust macro</a><ul>
<li><a href="#println-print"><code>println!</code>, <code>print!</code></a></li>
<li><a href="#todo"><code>todo!</code></a></li>
<li><a href="#panic"><code>panic!</code></a></li>
<li><a href="#dbg"><code>dbg!</code></a></li>
</ul>
</li>
<li><a href="#prelude-imported-std-libraries">Prelude (imported std libraries)</a></li>
<li><a href="#rust-ownership-ê°’ì—-ëŒ€í•œ-ì†Œìœ ê¶Œ">Rust ownership (ê°’ì— ëŒ€í•œ ì†Œìœ ê¶Œ)</a></li>
<li><a href="#references-and-borrowing">References and Borrowing</a></li>
<li><a href="#rust-syntax">Rust Syntax</a><ul>
<li><a href="#comments">Comments</a></li>
<li><a href="#document-comments">Document comments</a></li>
<li><a href="#constants-and-variables">Constants and Variables</a></li>
<li><a href="#built-in-scalar-data-types">Built-in scalar data types</a></li>
<li><a href="#char-type">Char type</a></li>
<li><a href="#compound-types">Compound Types</a></li>
<li><a href="#tuple-type">Tuple Type</a></li>
<li><a href="#array-type">Array Type</a></li>
<li><a href="#strê³¼-string-type">&amp;strê³¼ String Type</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#diverging-functions">Diverging functions</a></li>
<li><a href="#associated-function-indication-">Associated function indication <code>::</code></a></li>
<li><a href="#closure">closure</a></li>
<li><a href="#call-chaining-using-closure">Call chaining using closure</a></li>
<li><a href="#statements-and-expressions">Statements and expressions</a></li>
<li><a href="#control-flow">Control flow</a></li>
<li><a href="#ifelse"><code>if..else</code>:</a></li>
<li><a href="#loop-while-and-for"><code>loop</code>, <code>while</code> and <code>for</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#result-type">Result type</a></li>
<li><a href="#reference">Reference</a></li>
<li><a href="#methods">methods</a></li>
<li><a href="#field-init-shorthand">Field Init Shorthand</a></li>
<li><a href="#struct-update-syntax">Struct Update Syntax</a></li>
<li><a href="#tuple-structs">Tuple Structs</a></li>
</ul>
</li>
<li><a href="#generics">Generics</a><ul>
<li><a href="#generic-type">Generic Type</a></li>
<li><a href="#generic-functions">Generic functions</a></li>
<li><a href="#generic-implementations-generic-methods">Generic Implementations (Generic methods)</a></li>
<li><a href="#bounds">Bounds</a></li>
<li><a href="#where-clause">Where clause</a></li>
<li><a href="#associated-types">Associated types</a></li>
<li><a href="#phantom-type-parameters">Phantom type parameters</a></li>
</ul>
</li>
<li><a href="#traits">Traits</a></li>
<li><a href="#to-be-considered">To be considered</a></li>
<li><a href="#collections">collections</a><ul>
<li><a href="#box-stack-and-heap">Box, stack and heap</a></li>
<li><a href="#string">String</a></li>
<li><a href="#hash-map">hash map</a></li>
</ul>
</li>
<li><a href="#useful-code-or-crates">Useful code or crates</a><ul>
<li><a href="#read-stdin">Read stdin</a></li>
</ul>
</li>
<li><a href="#modules">Modules</a></li>
<li><a href="#macro">Macro</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#rust-attributes">Rust Attributes</a><ul>
<li><a href="#scope">Scope</a></li>
<li><a href="#attribute-arguments">Attribute arguments</a></li>
<li><a href="#frequently-used-attributes">Frequently Used Attributes</a></li>
<li><a href="#custom-cfg">Custom cfg</a></li>
<li><a href="#derive-attribute"><code>derive</code> attribute</a></li>
</ul>
</li>
<li><a href="#keywords">Keywords</a><ul>
<li><a href="#crate"><code>crate</code></a></li>
</ul>
</li>
<li><a href="#good-answer-to-understand">Good answer to understand</a></li>
<li><a href="#associated-items">Associated items</a></li>
<li><a href="#rust-rfc">Rust RFC</a></li>
</ul>
<h2 id="why-rust">Why Rust?</h2>
<ul>
<li>Performance</li>
<li>Reliability</li>
<li>Productivity</li>
</ul>
<h3 id="performance">Performance</h3>
<p>Rust is blazingly fast and memory-efficient: with no runtime or garbage collector, it can power performance-critical services, run on embedded devices, and easily integrate with other languages.</p>
<h3 id="reliability">Reliability</h3>
<p>Rustâ€™s rich type system and ownership model guarantee memory-safety and thread-safety â€” enabling you to eliminate many classes of bugs at compile-time.</p>
<h3 id="productivity">Productivity</h3>
<p>Rust has great documentation, a friendly compiler with useful error messages, and top-notch tooling â€” an integrated package manager and build tool, smart multi-editor support with auto-completion and type inspections, an auto-formatter, and more.</p>
<h2 id="roadamp-to-improve">Roadamp to improve</h2>
<ul>
<li>Building tools; ì§ê´€ì ì´ê³  ê°„ë‹¨í•œ building, packaging tool ì§€ì›</li>
<li>WebÂ­Assembly (Writing Web Apps); Binary instruction set in web browsers</li>
<li>Working with servers (server-side code) </li>
<li>Embedded systemì— ì í•©í•˜ë„ë¡ í–¥ìƒ</li>
</ul>
<h2 id="rust_1">Rust íŠ¹ì„±</h2>
<p>Open-source high-level and low-level system programming language</p>
<ul>
<li><code>Type safe</code>: The compiler assures that no operation will be applied to a variable of a wrong type.</li>
<li><code>Memory safe</code>: Rust pointers (known as references) always refer to valid memory.</li>
<li><code>Data race free</code>: Rust's borrow checker guarantees thread-safety by ensuring that multiple parts of a program can't mutate the same value at the same time.</li>
<li><code>Zero-cost abstractions</code>: Rust allows the use of high-level concepts, like iteration, interfaces, and functional programming, with minimal to no performance costs. The abstractions perform as well, as if you wrote the underlying code by hand.</li>
<li><code>Minimal runtime</code>: Rust has a very minimal and optional runtime. The language also has <strong>no garbage collector</strong> to manage memory efficiently. In this way Rust is most similar to languages like C and C++.</li>
<li><code>Targets bare metal</code>: Rust can target embedded and "bare metal" programming, making it suitable to write an operating system kernel or device drivers.</li>
</ul>
<h2 id="rust_2">ë‚´ê°€ ìƒê°í•˜ëŠ” rust íŠ¹ì„±</h2>
<ul>
<li>Variableê³¼ function typeì„ ê·¹ë„ë¡œ ì œì–´í•˜ì—¬ gabage collectionì´ í•„ìš”ì—†ë„ë¡ ë§Œë“¦</li>
</ul>
<h2 id="rust-module-system">Rust module system</h2>
<ul>
<li><code>Crates</code>: It's the smallest piece of code the Rust compiler can run.</li>
<li><code>Modules</code>: A number of modules become a crate; Related code items or items that are used together</li>
<li><code>Path</code>: Paths to access and use the code or items in Rust</li>
<li>Third-party crate registry: <a href="https://crates.io">crates.io</a></li>
</ul>
<h3 id="rust-standard-libary-and-useful-crates">Rust standard libary and useful crates</h3>
<ul>
<li><code>std</code> - The Rust standard library. In the Rust exercises, you'll notice the following modules:</li>
<li><code>std::collections</code> - Definitions for collection types, such as HashMap.</li>
<li><code>std::env</code> - Functions for working with your environment.</li>
<li><code>std::fmt</code> - Functionality to control output format.</li>
<li><code>std::fs</code> - Functions for working with the file system.</li>
<li><code>std::io</code> - Definitions and functionality for working with input/output.</li>
<li><code>std::path</code> - Definitions and functions that support working with file system path data.</li>
<li><code>structopt</code> - A third-party crate for easily parsing command-line arguments.</li>
<li><code>chrono</code> - A third-party crate to handle date and time data.</li>
<li><code>regex</code> - A third-party crate to work with regular expressions.</li>
<li><code>serde</code> - A third-party crate of serialization and deserialization operations for Rust data structures.</li>
</ul>
<h3 id="how-to-use-crates">How to use crates?</h3>
<pre><code class="rust">use std::fmt
</code></pre>

<h2 id="terms">Terms</h2>
<ul>
<li>Wasm (WebAssembly)</li>
</ul>
<p><code>WebAssembly</code> (abbreviated <code>Wasm</code>) is a binary instruction format for a stack-based virtual machine. <code>Wasm</code> is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</p>
<p><code>WebAssembly</code> is a new type of code that can be run in modern web browsers â€” it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.</p>
<blockquote>
<ul>
<li><strong>Emscripten SDK</strong> - compile wasm code and generate javascript stub and wasm binary.  </li>
<li><strong>Doc</strong>: <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">ğŸ”— WebAssembly</a></li>
</ul>
</blockquote>
<h2 id="latest-version">Latest version</h2>
<p><code>Version 1.60.0</code></p>
<h2 id="rust-installation">Rust installation</h2>
<pre><code class="bash"># Install rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Update rust
rustup update

# Uninstall rust
rustup self uninstall
</code></pre>

<ul>
<li><code>vscode</code>: <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">ğŸ”— ext install matklad.rust-analyzer</a></li>
<li><code>vim</code>: <a href="https://github.com/rust-lang/rust.vim">ğŸ”— rust.vim</a></li>
</ul>
<blockquote>
<p>All tools including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> are installed to the <code>~/.cargo/bin</code> directory.</p>
</blockquote>
<h3 id="cargo">Cargo</h3>
<p><code>cargo</code> is the rust build tool and package manager.</p>
<ul>
<li><code>cargo --version</code>: check the rust version</li>
<li><code>cargo new --vcs=git</code>: create new project with <code>git init</code></li>
<li><code>cargo new</code></li>
<li><code>cargo build</code>: build your project with</li>
<li><code>cargo run</code>: run your project with</li>
<li><code>cargo test</code>: test your project with</li>
<li><code>cargo check</code>: checks your code to make sure it compiles but doesnâ€™t produce an executable</li>
<li><code>cargo doc</code>: build documentation for your project with</li>
<li><code>cargo doc --open</code>: í˜„ì¬ crateì˜ html ë¬¸ì„œ ìƒì„±</li>
<li><code>cargo publish</code>: publish a library to <code>crates.io</code> with</li>
<li>Add dependent crates to a project by adding the crate name to the Cargo.toml file.</li>
<li><code>cargo fmt</code>: reformats your code according to the community code style.</li>
<li><code>cargo fix</code>: Automatically fix lint warnings reported by rustc</li>
</ul>
<blockquote>
<p><strong>manual</strong>: <a href="https://doc.rust-lang.org/cargo/index.html">ğŸ”— cargo doc</a></p>
</blockquote>
<h4 id="cargo-versioning">Cargo versioning</h4>
<p>CargoëŠ” ë²„ì „ì„ ëª…ì‹œí•˜ëŠ” í‘œì¤€ì— í•´ë‹¹í•˜ëŠ” <a href="https://semver.org/">Semantic Versioning(semver)</a>ì„ ì´ìš©í•©ë‹ˆë‹¤.</p>
<pre><code class="toml"># Example
rand = &quot;0.8.3&quot;
</code></pre>

<p>The number 0.8.3 is actually shorthand for ^0.8.3, which means any version that is at least 0.8.3 but below 0.9.0. </p>
<h4 id="cargotoml-toml-file-for-cargo-config">Cargo.toml (TOML file for cargo config)</h4>
<p><code>Cargo.toml</code>: TOMLë¡œ ì •ì˜ëœ cargo configuration file</p>
<p>TOML's syntax primarily consists of key = "value" pairs, [section names], and # comments. TOML's syntax somewhat resembles that of .INI files, but it includes a formal specification, whereas the INI file format suffers from many competing variants.</p>
<p>Its specification includes a list of supported data types: String, Integer, Float, Boolean, Datetime, Array, and Table.</p>
<pre><code class="toml"># This is a TOML document.

title = &quot;TOML Example&quot;

[owner]
name = &quot;Tom Preston-Werner&quot;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &quot;192.168.1.1&quot;
ports = [ 8000, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = &quot;10.0.0.1&quot;
  dc = &quot;eqdc10&quot;

  [servers.beta]
  ip = &quot;10.0.0.2&quot;
  dc = &quot;eqdc10&quot;

[clients]
data = [ [&quot;gamma&quot;, &quot;delta&quot;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  &quot;alpha&quot;,
  &quot;omega&quot;
]
</code></pre>

<h4 id="cargolock">Cargo.lock</h4>
<ul>
<li><code>go.sum</code>ê³¼ ê°™ì´ ë‹¤ìš´ë¡œë“œí•œ crate (package)ì— ëŒ€í•œ versionê³¼ ì •ë³´ë¥¼ ëª…ì„¸í•˜ì—¬, ì´í›„ ë™ì¼í•œ crate versionìœ¼ë¡œ buildì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•¨.</li>
<li><code>cargo update</code>: crateì˜ minor versionë§Œ ì—…ë°ì´íŠ¸í•¨; major versionì„ ë³€ê²½í•˜ë ¤ë©´, Cargo.tomlì˜ major versionì„ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤.</li>
</ul>
<h3 id="useful-development-tool">Useful development tool</h3>
<pre><code class="bash">rustup component add rustfmt
rustup component add clippy
</code></pre>

<ul>
<li><code>cargo fmt</code>: <code>rustfmt</code>; Automatic Formatting development tool</li>
<li><code>cargo fix</code>: Automatically fix lint warnings reported by rustc</li>
<li><code>cargo clippy</code>: <code>clippy</code>; A collection of lints to analyze your code to catch common mistakes and improve your code.</li>
</ul>
<h3 id="rust-build-tools">Rust build tools</h3>
<ul>
<li><code>rustc</code>: Rust compiler</li>
<li><code>rustup</code>: Rust toolchain installer; Rust tool manager</li>
<li><code>rustc --version</code>: check rust version</li>
<li><code>rustc RUST_FILE.rs</code>: build the rust binary</li>
</ul>
<blockquote>
<p>ë‹¤ìŒ tool í™•ì¸ í•„ìš”<br />
<code>rustc</code>, <code>rustdoc</code>, <code>rustfmt</code>, <code>rust-gdb</code>, <code>rust-lldb</code>, <code>rustup</code></p>
</blockquote>
<h3 id="rustup-cargo-command-completion">Rustup &amp; cargo command completion</h3>
<p>Rust build toolì— ëŒ€í•œ tab completion</p>
<pre><code class="bash">mkdir -p ~/.local/share/bash-completion/completions
rustup completions bash rustup &gt;&gt; ~/.local/share/bash-completion/completions/rustup
rustup completions bash cargo &gt;&gt; ~/.local/share/bash-completion/completions/cargo
source ~/.local/share/bash-completion/completions/rustup
source ~/.local/share/bash-completion/completions/cargo
</code></pre>

<h3 id="rust-cookbook">Rust Cookbook</h3>
<p>Rust crateì˜ ì¢…ë¥˜ë¥¼ ë¶„ë¥˜í•œ cookbookì—ì„œ í•„ìš”í•œ libraryë¥¼ ê°€ì¥ ë¨¼ì € ì°¾ì!</p>
<blockquote>
<p>ğŸ”— <a href="https://rust-lang-nursery.github.io/rust-cookbook">Rust Cookbook</a></p>
</blockquote>
<h2 id="helloworld-with-cargo">Helloworld with cargo</h2>
<pre><code class="bash"># create new project
cargo new hello-rust
cd hello-rust
tree
#.
#â”œâ”€â”€ Cargo.toml # for the metadata and dependencies of the project
#â””â”€â”€ src # rust code
#    â””â”€â”€ main.rs

# fn main() is the starting point of all rust appliciations.
cat src/main.rs 
# fn main() {
#     println!(&quot;Hello, world!&quot;);
# }

# Building and running
cargo run
#    Compiling hello-rust v0.1.0 (/home/neoul/projects/programming-note/rust/hello-rust)
#     Finished dev [unoptimized + debuginfo] target(s) in 0.54s
#      Running `target/debug/hello-rust`
# Hello, world!

tree
#.
#â”œâ”€â”€ Cargo.lock # [FIXME] what is it?
#â”œâ”€â”€ Cargo.toml
#â”œâ”€â”€ src
#â”‚Â Â  â””â”€â”€ main.rs
#â””â”€â”€ target
#    â”œâ”€â”€ CACHEDIR.TAG # 
#    â””â”€â”€ debug
#        â”œâ”€â”€ build
#        â”œâ”€â”€ deps
#        â”‚Â Â  â”œâ”€â”€ hello_rust-542ed0184760343f
#        â”‚Â Â  â””â”€â”€ hello_rust-542ed0184760343f.d
#        â”œâ”€â”€ examples
#        â”œâ”€â”€ hello-rust
#        â”œâ”€â”€ hello-rust.d
#        â””â”€â”€ incremental
</code></pre>

<h2 id="how-to-add-external-crates">How to add external crates</h2>
<p>ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ ì‚¬ìš©ë²•</p>
<pre><code class="bash"># Edit Cargo.toml
[dependencies]
ferris-says = &quot;0.2&quot;
</code></pre>

<pre><code class="rust">// in rust code
use ferris_says::say;
</code></pre>

<p><code>cargo build</code>: Cargo will install our dependency for us.</p>
<h2 id="enabling-rust-backtrace">Enabling rust backtrace</h2>
<p>Rust display the backtrace if running with <code>RUST_BACKTRACE=1</code>.</p>
<pre><code class="bash">$ ./main 
..
$ RUST_BACKTRACE=1 ./main 
thread 'main' panicked at 'not yet implemented: To Do!', main.rs:2:5
stack backtrace:
   0: rust_begin_unwind
...
   2: main::main
   3: core::ops::function::FnOnce::call_once
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>

<h2 id="rust-macro">Rust macro</h2>
<p>Rust macroëŠ” ê°œìˆ˜ê°€ ê°€ë³€ì ì¸ ì…ë ¥ ì¸ìˆ˜ë¥¼ ì·¨í•˜ëŠ” í•¨ìˆ˜</p>
<ul>
<li><code>println!</code>, <code>print!</code></li>
<li><code>todo!</code></li>
<li><code>panic!</code></li>
<li><code>dbg!</code></li>
</ul>
<h3 id="println-print"><code>println!</code>, <code>print!</code></h3>
<p>ê°€ë³€ ì¸ìˆ˜ë¥¼ ë°›ì•„ <code>stdout</code>ì— ì¶œë ¥</p>
<pre><code class="rust">// - If it called a function instead, it would be entered as println (without the `!`).
// - &quot;Hello, world!&quot;: string representation of the string
// - {}ì— ì¸ìˆ˜ì˜ ê°’ ëŒ€ì²´ ì‚½ì…; placeholderë¼ ë¶€ë¦„
println!(&quot;Hello, {}!&quot;, &quot;world&quot;);
</code></pre>

<h3 id="todo"><code>todo!</code></h3>
<p>ì™„ì„±ë˜ì§€ ì•Šì€ í•¨ìˆ˜ì˜ prototype ì ê²€ ë° ì„ ì–¸, í˜¸ì¶œì‹œ exception ë°œìƒ</p>
<pre><code class="rust">// todo! - Display &quot;Hello, world!&quot; with an exception.
fn main() {
  todo!(&quot;Display the message by using the println!() macro&quot;);
}
</code></pre>

<h3 id="panic"><code>panic!</code></h3>
<p>The call to <code>panic!</code> causes the error message contained in the last two lines.</p>
<pre><code class="rust">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre>

<h3 id="dbg"><code>dbg!</code></h3>
<p>Another way to print out a value using the Debug format is to use the <code>dbg!</code> macro, which takes ownership of an expression, prints the file and line number of where that dbg! macro call occurs in your code along with the resulting value of that expression, and returns ownership of the value.</p>
<blockquote>
<p>Note: print message to <code>stderr</code>.</p>
</blockquote>
<pre><code class="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let scale = 2;
    let rect = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };
    let rect = dbg!(rect);
    println!(
        &quot;The area of the rectangle {:?} is {} square pixels.&quot;,
        rect,
        area(&amp;rect)
    );
}
fn area(rect :&amp;Rectangle) -&gt; u32 {
    return rect.width * rect.height;
}
// [src/main.rs:16] 30 * scale = 60
// [src/main.rs:20] rect = Rectangle {
//     width: 60,
//     height: 50,
// }
// The area of the rectangle Rectangle { width: 60, height: 50 } is 3000 square pixels.
</code></pre>

<h2 id="prelude-imported-std-libraries">Prelude (imported std libraries)</h2>
<p>The prelude is the list of things that Rust automatically imports into every Rust program. </p>
<p><a href="https://doc.rust-lang.org/std/prelude/index.html">ğŸ”— Module std::prelude</a></p>
<p>For example ... </p>
<ul>
<li><code>std::result::Result::{self, Ok, Err}</code>, a type for functions that may succeed or fail. Like Option, its variants are exported as well.</li>
<li><code>std::string::{String, ToString}</code>, heap-allocated strings.</li>
<li><code>std::vec::Vec</code>, a growable, heap-allocated vector.</li>
</ul>
<h2 id="rust-ownership">Rust ownership (ê°’ì— ëŒ€í•œ ì†Œìœ ê¶Œ)</h2>
<ul>
<li>Rustì˜ ëª¨ë“  ê°’ì€ ownerë¼ëŠ” ë³€ìˆ˜ë¥¼ ê°€ì§€ë©°, í•˜ë‚˜ì˜ ê°’ì€ í•˜ë‚˜ì˜ owner ë³€ìˆ˜ì—ë§Œ ì¢…ì†ë  ìˆ˜ ìˆìŒ</li>
<li>ë§Œì•½, copy traitì´ ì •ì˜ë˜ì–´ ìˆìœ¼ë©´, deep copyë¥¼ ìˆ˜í–‰í•˜ë‚˜ ì•„ë‹Œ ê²½ìš° ownership moveê°€ ì¼ì–´ë‚¨(?)</li>
<li>ownership move: ë‹¤ìˆ˜ì˜ ë³€ìˆ˜ê°€ í•˜ë‚˜ì˜ ê°’ì„ ê°€ë¦¬í‚¬ ìˆ˜ ì—†ìœ¼ë©°, ownership move (ì†Œìœ ê¶Œ ì´ì „)ê°€ ìˆ˜í–‰ë¨</li>
<li>ownerê°€ ì¢…ì† ë²”ìœ„ (curly bracket)ì„ ë²—ì–´ë‚˜ë©´, drop (free)ë¨ (C++ RAII íŒ¨í„´)</li>
</ul>
<pre><code class="rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

// Stringì€ copy traitì´ ì •ì˜ë˜ì§€ ì•Šì•„ ownership moveê°€ ë°œìƒí•˜ë©°, ì´í›„ s1ì„ ì‚¬ìš©í•  ê²½ìš° ì˜¤ë¥˜ ë°œìƒ
// error[E0382]: use of moved value: `rect` ë°œìƒ
</code></pre>

<ul>
<li>í•¨ìˆ˜ì— ê°’ì„ ì¸ìë¡œ ë„˜ê¸¸ ê²½ìš° ownershipë„ ë³€ê²½ë¨</li>
<li>deep copy: copy traitì´ êµ¬í˜„ëœ structureë‚˜ built-in scalarëŠ” deep copyë¥¼ ìˆ˜í–‰í•¨</li>
<li>shallow copy: rustì—ì„œëŠ” ì¼ì–´ë‚˜ì§€ ì•ŠìŒ</li>
<li>heapì— í• ë‹¹ë˜ëŠ” ê°€ë³€ (mutable)ì˜ structureëŠ” ë³´í†µ referenceë¡œ ownership ê´€ë¦¬ë¥¼ íšŒí”¼</li>
</ul>
<p>Here are some of the types that implement Copy:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values true and false.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li><code>Tuples</code>, if they only contain types that also implement Copy. For example, <code>(i32, i32)</code> implements Copy, but <code>(i32, String)</code> does not.</li>
</ul>
<blockquote>
<ul>
<li>https://velog.io/@timothy160620/Learning-Rust</li>
<li>https://showx123.tistory.com/81</li>
</ul>
</blockquote>
<h2 id="references-and-borrowing">References and Borrowing</h2>
<p><img alt="Figure 4-5: A diagram of &amp;String s pointing at String s1" src="https://doc.rust-lang.org/book/img/trpl04-05.svg" /></p>
<pre><code class="rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>

<blockquote>
<p>Note: The opposite of referencing by using &amp; is dereferencing, which is accomplished with the dereference operator, <code>*</code>. Weâ€™ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</p>
</blockquote>
<h2 id="rust-syntax">Rust Syntax</h2>
<h3 id="comments">Comments</h3>
<p>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line.</p>
<pre><code class="rust">// Hello, world.
</code></pre>

<h3 id="document-comments">Document comments</h3>
<p>Rust also has a particular kind of comment for documentation, known conveniently as a documentation comment, that will generate HTML documentation. Documentation comments use three slashes, <code>///</code>, instead of two and support Markdown notation for formatting the text.</p>
<pre><code class="rust">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>

<p>Another style of doc comment, <code>//!</code>, is used to describe the crate introduction.</p>
<pre><code class="rust">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.
</code></pre>

<blockquote>
<p><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html">[FIXME] document comments ë‹¤ì‹œ ì½ê¸°</a></p>
</blockquote>
<h3 id="constants-and-variables">Constants and Variables</h3>
<ul>
<li>A value is not assigned, it is binded to a variable. pythonê³¼ ê°™ì€ bind ê°œë…ì„ ì°¨ìš©í•¨</li>
<li>Constants must be computed at compile time.</li>
<li>The equal sign (<code>=</code>) tells Rust we want to bind something to the variable now. </li>
</ul>
<pre><code class="rust">// í•¨ìˆ˜ ì„ ì–¸
fn func()

// ë³€ìˆ˜ ì„ ì–¸
let a_number;

// ë³€ìˆ˜ì— ê°’ ë°”ì¸ë”©; variable binding to a value
// variable binding == value assginment (ê°’í• ë‹¹)
let a_number = 10;

// ê°’ì´ ë°”ì¸ë”©ëœ ë³€ìˆ˜ëŠ” ê°’ re-ë°”ì¸ë”© ë¶ˆê°€ëŠ¥!!
a_number = 11;

// mut (mutable, ë³€í•  ìˆ˜ ìˆëŠ”)ë¡œ ì„ ì–¸í•  ê²½ìš°
let mut b_number = 10;
// variable binding ë³€ê²½ ê°€ëŠ¥
b_number = 11;

// variable shadowing (ë³€ìˆ˜ ì„€ë„ì‰)
// letìœ¼ë¡œ ë™ì¼ëª…ì˜ ë³€ìˆ˜ë¥¼ ê³„ì† ì„ ì–¸í•  ìˆ˜ ìˆìŒ
// ì´ê²ƒìœ¼ë¡œ ë³€ìˆ˜ì˜ ê°’ì„ ë³€ê²½í•˜ëŠ” ê²ƒê³¼ ê°™ì€ íš¨ê³¼ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŒ
let x = 5;
let x = x + 1;
let x = x * 2;
println!(&quot;The value of x is: {}&quot;, x); // The value of x is: 12

// shardowingìœ¼ë¡œ ë³€ìˆ˜ì˜ typeì´ ë³€ê²½ë˜ëŠ” ê²ƒì²˜ëŸ¼ ë™ì‘ì‹œí‚¬ ìˆ˜ ìˆë‹¤.
let spaces = &quot;   &quot;;
let spaces = spaces.len(); // spaceëŠ” intergerê°€ ë¨

// ë§Œì•½, mutë¥¼ ì‚¬ìš©í•˜ê²Œë˜ë©´, type ë³€ê²½ì€ ë¶ˆí—ˆ
let mut spaces = &quot;   &quot;;
spaces = spaces.len(); // cause an error

// constant (ìƒìˆ˜)
// - constants use uppercase with underscores.
// - constants must be computed at compile time.
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>

<h3 id="built-in-scalar-data-types">Built-in scalar data types</h3>
<p>Rustì—ì„œ ì§€ì›í•˜ëŠ” scalar data typeì€ ë‹¤ìŒê³¼ ê°™ë‹¤.</p>
<pre><code class="rust">i8, i16, i32, i64 // signed integer number (default: i32)
u8, u16, u32, u64 // unsigned integer number
isize, usize // architecture-dependent number
f32, f64 // floating point number (default f64)
bool // true, false boolean value
char // A 21-bit integer represent a character 
     // that's padded to be 32 bits wide for unicode
&amp;str // a string slice consists of characters.
     // This is immutable string data! (Read-only)
String // It is mutable string data allocated to the heap area.
</code></pre>

<ul>
<li>Rust is a statically typed language. ë”°ë¼ì„œ compilerê°€ ëª¨ë“  ë³€ìˆ˜ì˜ ì •í™•í•œ data typeì„ ì•Œì•„ì•¼ í•¨</li>
<li><code>let VAR: TYPE</code>ìœ¼ë¡œ variableì˜ typeì„ ëª…ì‹œ</li>
<li><code>println!</code> ì‚¬ìš©ì‹œ data type suffixë¥¼ ì¶”ê°€í•´ compilerê°€ typeì„ ì¸ì§€í•˜ë„ë¡ ì…ë ¥í•´ì•¼ í•¨.</li>
<li><code>String</code> is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text. This is not a built-in type.</li>
</ul>
<pre><code class="rust">// Integer literal
let _i = 1000; // i32 assigned by default
let _i: i32 = 1000i32; // suffix for type direction
let _i: i32 = 98_222; // = 98222 Decimal for visual separation
let _i: i32 = 0xff; // Hex
let _i: i32 = 0o77; // Octal
let _i: i32 = 0b1111_0000; // Binary
let _i: u8 = b'A'; // Byte (u8 only)

// Float literal
let _number_64 = 4.0;      // compiler infers the value to use the default type f64
let _number_32: f32 = 5.0; // type f32 specified via annotation

// All of the primitive number types in Rust support mathematical operations
// like addition, subtraction, multiplication, and division.
// When we call the println macro, we add the data type suffix 
// to each literal number to inform Rust about the data type. 

// Addition, Subtraction, and Multiplication
println!(&quot;1 + 2 = {} and 8 - 5 = {} and 15 * 3 = {}&quot;, 1u32 + 2, 8i32 - 5, 15 * 3);

// Integer and Floating point division
println!(&quot;9 / 2 = {} but 9.0 / 2.0 = {}&quot;, 9u32 / 2, 9.0 / 2.0);

// integer types
let sum = 5 + 10; // addition
let difference = 95.5 - 4.3; // subtraction
let product = 4 * 30; // multiplication
let quotient = 56.7 / 32.2; // division
let remainder = 43 % 5; // remainder

// floating point types
let x = 2.0; // f64
let y: f32 = 3.0; // f32

// boolean type
let t = true;
let f: bool = false; // with explicit type annotation

// character
let c = 'z';
let z = 'â„¤';
let heart_eyed_cat = 'ğŸ˜»';
</code></pre>

<h3 id="char-type">Char type</h3>
<ul>
<li>Rustâ€™s <code>char</code> type is four bytes in size and represents a Unicode Scalar Value.</li>
<li>Unicode Scalar Values range from <code>U+0000</code> to <code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive.</li>
<li><code>char</code> type is a 21-bit integer represent a character that's padded to be 32 bits wide for unicode.</li>
<li>Char literals use single quotes.<code>'C'</code></li>
<li><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded Text with Strings</a></li>
</ul>
<h3 id="compound-types">Compound Types</h3>
<p>Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.</p>
<h3 id="tuple-type">Tuple Type</h3>
<p>Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<pre><code class="rust">let tup: (i32, f64, u8) = (500, 6.4, 1);

// [Tuple destructuring]
// To get the individual values out of a tuple ...
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
println!(&quot;The value of y is: {}&quot;, y); // The value of y is: 6.4

// [Access a tuple element directly]
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
</code></pre>

<blockquote>
<p>â“ The tuple without any values, (), is a special type that has only one value, also written (). The type is called the unit type and the value is called the unit value. Expressions implicitly return the unit value if they donâ€™t return any other value.</p>
</blockquote>
<h3 id="array-type">Array Type</h3>
<ul>
<li>Unlike a tuple, every element of an array must have the same type.</li>
<li>Unlike arrays in some other languages, arrays in Rust have a fixed length.</li>
<li>Arrays are useful when you want your data allocated on the stack rather than the heap.</li>
<li>Flexible size arrayê°€ í•„ìš”í•˜ë‹¤ë©´ <code>Vec&lt;T&gt;</code>ë¥¼ ì‚¬ìš©</li>
</ul>
<pre><code class="rust">let a = [1, 2, 3, 4, 5];
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
let a: [i32; 5] = [1, 2, 3, 4, 5]; // [Type; Length]
let a = [3; 5]; // [3, 3, 3, 3, 3]ìœ¼ë¡œ ì´ˆê¸°í™”

// [Access an array element]
let first = a[0];
let second = a[1];

// mutableí•´ì•¼ Arrary element ë³€ê²½ ê°€ëŠ¥í•¨
let mut a = [1, 2, 3, 4, 5];
a[1] = 100;
</code></pre>

<h3 id="str-string-type">&amp;strê³¼ String Type</h3>
<ul>
<li>&amp;str as a pointer to immutable string data. String literals are all of type &amp;str.</li>
</ul>
<h3 id="functions">Functions</h3>
<ul>
<li><code>fn</code> keywardë¥¼ ì‚¬ìš©</li>
<li>All letters of function names and variables are lowercase and underscores (<code>_</code>) separate words.</li>
<li>A set of parentheses and curly brackets are followed to the function name.</li>
<li>In function signatures, you must declare the type of each parameter that you want to input.</li>
<li>The function returns a concrete type: The Rust compiler needs to know how much space every function's return type requires.</li>
</ul>
<pre><code class="rust">fn main() {
  another_function(5);
  print_labeled_measurement(5, 'h');
}

fn another_function(x: i32) {
  println!(&quot;The value of x is: {}&quot;, x);
}

fn print_labeled_measurement(value: i32, unit_label: char) {
  println!(&quot;The measurement is: {}{}&quot;, value, unit_label);
}

fn four() -&gt; i32 {
  4; // error because it becomes a statement
}

fn five() -&gt; i32 {
  5 // no semicolon; return the value as an expression
}

fn six() -&gt; i32 { // ëª…ì‹œì  ë°˜í™˜
  return 6; // ok
}

fn seven() -&gt; i32 {
  return 7 // ok
}

fn main() {
  let x = five();
  println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>

<h3 id="diverging-functions">Diverging functions</h3>
<p>Diverging functions never return. They are marked using <code>!</code>, which is an empty type.</p>
<blockquote>
<p>serverë“±ì˜ non-terminated appì—ì„œ ì‚¬ìš©í•˜ë©´ ë  ë“¯ ...</p>
</blockquote>
<pre><code class="rust">fn foo() -&gt; ! {
  panic!(&quot;This call never returns.&quot;);
}
</code></pre>

<h3 id="associated-function-indication">Associated function indication <code>::</code></h3>
<pre><code class="rust">let mut guess = String::new();
</code></pre>

<p>The <code>::</code> syntax in the <code>::new</code> line indicates that new is an associated function of the String type. An associated function is a function thatâ€™s implemented on a type, in this case String.</p>
<h3 id="closure">closure</h3>
<p>Closures are functions that can capture the enclosing environment. For example, a closure that captures the x variable:</p>
<p><code>|val| val + x</code></p>
<ul>
<li><strong>capturing</strong> and <strong>bollowing</strong>: closure í•¨ìˆ˜ê°€ variableì— í• ë‹¹ë  ë•Œ ë™ì¼ namespaceì— ìˆëŠ” ë³€ìˆ˜ë¥¼ captureí•˜ì—¬ ì‚¬ìš©í•¨</li>
<li>by reference: <code>&amp;T</code></li>
<li>by mutable reference: <code>&amp;mut T</code></li>
<li>by value: <code>T</code></li>
<li><code>move</code> ì‚¬ìš©ì‹œ variableì˜ ownershipì„ ê°€ì ¸ê° </li>
<li>e.g. <code>let contains = move |needle| haystack.contains(needle);</code></li>
<li>input &amp; output parameterë¡œ ì‚¬ìš©ê°€ëŠ¥</li>
<li>type boundì— ì•„ë˜ì™€ ê°™ì€ argument functionì˜ traitì„ ì§€ì •í•´ì•¼ í•¨<ul>
<li><code>Fn</code>: the closure uses the captured value by reference (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: the closure uses the captured value by mutable reference (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: the closure uses the captured value by value (<code>T</code>)</li>
</ul>
</li>
<li>iterator ë™ì‘ì„ êµ¬í˜„í•  ë•Œ ì‚¬ìš© e.g. <code>Iterator::any</code></li>
</ul>
<pre><code class="rust">// Increment via closures and functions.
fn function(i: i32) -&gt; i32 {
    i + 1
}

// Closures are anonymous, here we are binding them to references
// Annotation is identical to function annotation but is optional
// as are the `{}` wrapping the body. These nameless functions
// are assigned to appropriately named variables.
let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
let closure_inferred = |i| i + 1;

let mut i = 1;
i = function(i); // 2
i = closure_annotated(i); // 3
i = closure_inferred(i); // 4
println!(&quot;closure example i: {}&quot;, i);
// let i = 1;
// Call the function and closures.
println!(&quot;function: {}&quot;, function(i)); // 5
println!(&quot;closure_annotated: {}&quot;, closure_annotated(i)); // 5
println!(&quot;closure_inferred: {}&quot;, closure_inferred(i)); // 5

// A closure taking no arguments which returns an `i32`.
// The return type is inferred.
let one = || 1;
println!(&quot;closure returning one: {}&quot;, one());

use std::mem;
let color = String::from(&quot;green&quot;);

// bollow immutable reference of the color variable.
let print = || println!(&quot;`color`: {}&quot;, color);
print();

let _reborrow = &amp;color;
print();

// A move or reborrow is allowed after the final use of `print`
let _color_moved = color;
// print(); // í˜¸ì¶œ ë¶ˆê°€; color already moved to _color_moved


let mut count = 0;
// bollow mutable count reference.
let mut inc = || {
    count += 1;
    println!(&quot;`count`: {}&quot;, count);
};

// Call the closure using a mutable borrow.
inc();

// The closure no longer needs to borrow `&amp;mut count`. Therefore, it is
// possible to reborrow without an error
let _count_reborrowed = &amp;mut count; 

// `consume` consumes the variable so this can only be called once.
let movable = Box::new(3);
let consume = || {
    println!(&quot;`movable`: {:?}&quot;, movable);
    mem::drop(movable);
};
consume();
// consume(); // í˜¸ì¶œ ë¶ˆê°€; The bollowed variable is not available.
// ^ TODO: Try uncommenting this line.

// move ì‚¬ìš©ì‹œ ownershipì„ ê°€ì ¸ê°
let haystack = vec![1, 2, 3];
let contains = move |needle| haystack.contains(needle);
println!(&quot;{}&quot;, contains(&amp;1));

// Functional approach
let sum_of_squared_odd_numbers: u32 =
    (0..).map(|n| n * n)                             // All natural numbers squared
          .take_while(|&amp;n_squared| n_squared &lt; upper) // Below upper limit
          .filter(|&amp;n_squared| is_odd(n_squared))     // That are odd
          .fold(0, |acc, n_squared| acc + n_squared); // Sum them
println!(&quot;functional Approach: {}&quot;, sum_of_squared_odd_numbers);
</code></pre>

<h4 id="call-chaining-using-closure">Call chaining using closure</h4>
<pre><code class="rust">// call chaining using closure
fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}
let upper = 1000;
let sum_of_squared_odd_numbers: u32 = (0..)
    .map(|n| n * n) // All natural numbers squared
    .take_while(|&amp;n_squared| n_squared &lt; upper) // Below upper limit
    .filter(|&amp;n_squared| is_odd(n_squared)) // That are odd
    .fold(0, |acc, n_squared| acc + n_squared); // Sum them
println!(&quot;functional Approach: {}&quot;, sum_of_squared_odd_numbers);
</code></pre>

<h3 id="statements-and-expressions">Statements and expressions</h3>
<p>RustëŠ” Statementì™€ expressionì˜ êµ¬ë¶„ì´ ë‹¤ìŒê³¼ ê°™ì´ ëª…í™•í•¨.</p>
<ul>
<li>Statements are instructions that perform some action and do not return a value.</li>
<li>Expressions evaluate to a resulting value and return the result value.</li>
<li>Expressions do not include ending semicolons.</li>
<li>If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.</li>
<li>javascriptì™€ ìœ ì‚¬í•˜ê²Œ ì„¸ë¯¸ì½œë¡ (<code>;</code>) ì—†ì´ function ë§ˆì§€ë§‰ ë¬¸ì¥ì´ ëë‚˜ë©´, ê·¸ ë§ˆì§€ë§‰ ê²°ê³¼ë¥¼ ë°˜í™˜í•¨ (as an expression)</li>
</ul>
<blockquote>
<p>Expressions in rust: function call, value, {} (ë¸”ë¡)</p>
</blockquote>
<pre><code class="rust">fn main() {
  // error ë°œìƒ let yëŠ” return value ì—†ìŒ
  // expressionì´ ì•„ë‹ˆë¯€ë¡œ xì— binding ë¶ˆê°€
  let x = (let y = 6);

  // 4ë¡œ íŒì •ëœ {} ì•ˆì˜ ê°’ì´ yì— í• ë‹¹
  // x + 1ì—ëŠ” ì„¸ë¯¸ì½œë¡ (;) ì´ ì—†ìœ¼ë©° expressionìœ¼ë¡œ íŒì •, ê°’ì„ ë°˜í™˜
  let y = {
    let x = 3;
    x + 1
  };
  println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>

<h3 id="control-flow">Control flow</h3>
<h4 id="ifelse"><code>if..else</code>:</h4>
<ul>
<li>conditionì€ ë°˜ë“œì‹œ booleanì„ ë°˜í™˜í•´ì•¼ í•¨</li>
<li>parenthesis <code>()</code> ëŠ” ì‚¬ìš©ì•ˆí•¨</li>
<li><code>arms</code>: ê°ˆë˜?; conditionì— ë”°ë¼ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë¸”ë¡ì„ ë§í•¨</li>
<li><code>let</code> í• ë‹¹ ì—°ì‚° (<code>=</code>)ì— <code>if..else</code> ì‚¬ìš© ê°€ëŠ¥</li>
</ul>
<pre><code class="rust">let number = 6;
if number % 4 == 0 {
  println!(&quot;number is divisible by 4&quot;);
} else if number % 3 == 0 {
  println!(&quot;number is divisible by 3&quot;);
} else if number % 2 == 0 {
  println!(&quot;number is divisible by 2&quot;);
} else {
  println!(&quot;number is not divisible by 4, 3, or 2&quot;);
}

if number { // error - expected bool, found integral variable
  println!(&quot;number was three&quot;);
}

// 
let number = if condition &gt; 4 {
  if condition &gt; 8 {
    11
  } else {
    5
  }
} else {
  3
};

println!(&quot;The value of number is: {}&quot;, number); // 5
</code></pre>

<h4 id="loop-while-and-for"><code>loop</code>, <code>while</code> and <code>for</code></h4>
<pre><code class="rust">loop {
  println!(&quot;again!&quot;);
  // ...
  break;
}

let mut number = 3;
while number != 0 {
  println!(&quot;{}!&quot;, number);
  number = number - 1;
  println!(&quot;LIFTOFF!!!&quot;);
}


let a = [10, 20, 30, 40, 50];
for element in a.iter() {
  // forë¬¸ ë‚´ì—ì„œ element ì‚­ì œí•´ë„ panic X
  println!(&quot;the value is: {}&quot;, element);
}

// range
for number in (1..4).rev() {
  println!(&quot;{}!&quot;, number);
}
println!(&quot;LIFTOFF!!!&quot;);
</code></pre>

<h4 id="match"><code>match</code></h4>
<pre><code class="rust">fn main() {
  // Destructuring values in match
  // - rustëŠ” ë³µì¡í•œ typeì„ matchë¡œ wrapping structureë¥¼ ë²—ê²¨ë‚´ì–´ ì²˜ë¦¬í•¨
  // - destructuring typeì´ ë‹¤ë¥¼ ê²½ìš° match, if let í• ë‹¹ ë¶ˆê°€
  // - destructuring 
  let member = 13;
  match member {
      1 =&gt; println!(&quot;1&quot;),
      2 | 3 | 4 =&gt; println!(&quot;2,3,4&quot;),
      5..=10 =&gt; println!(&quot;5..10&quot;),
      _ =&gt; println!(&quot;_&quot;)
  }

  // tuple
  let triple = (0, 1, -3);
  match triple {
      (0, y, z) =&gt; println!(&quot;{},{}&quot;, y, z),
      (1, ..) =&gt; println!(&quot;first is 1&quot;), // .. ignore the rest
      _ =&gt; println!(&quot;??&quot;)
  }

  // arrays/slices
  let array = [3, -2, 6];
  match array {
      [0, second, third] =&gt; {
          println!(&quot;second {}, thrid {}&quot;, second, third);
      }
      [1, _, third] =&gt; println!(&quot;thrid {}&quot;, third), // ignore a value with _
      // The code below would not compile
      // [-1, second] =&gt; println!(&quot;compile error&quot;),
      // store middle values to another array/slice
      [3, middle @.., last] =&gt; println!(&quot;{:?} {:?}&quot;, middle, last),
      _ =&gt; ()
  }

  // enums
  #[allow(dead_code)]
  #[derive(Debug)]
  enum Color {
      Red,
      Blue,
      Green,
      RGB(u32, u32, u32),
      CMYK(u32, u32, u32, u32)
  }
  let color = Color::RGB(122, 17, 40);
  match color {
      Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
      Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
      Color::Green =&gt; println!(&quot;The color is Green!&quot;),
      Color::RGB(r, g, b) =&gt;
          println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
      Color::CMYK(c, m, y, k) =&gt;
          println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
              c, m, y, k),
      // all matching case must be in the scope.
  }

  // pointers/ref
  // dereference in matching
  let reference: &amp;u32 = &amp;4;
  match reference {
      &amp;val =&gt; println!(&quot;{:?}&quot;, val) // if matched, it drops `&amp;`
  }
  // To avoid the `&amp;`, you dereference before matching.
  match *reference {
      val =&gt; println!(&quot;{:?}&quot;, val)
  }

  let _not_a_reference = 3;
  let ref _is_a_reference = 3; // &amp;i32; explicit reference
  let value = 5;
  let mut mut_value = 6;

  let rr = match value { // create the reference of r
      ref r =&gt; r
  };
  println!(&quot;{:?}, {:?}&quot;, value, rr);
  match mut_value {
      ref mut m =&gt; {
          // Got a reference. Gotta dereference it before we can add anything to it.
          *m += 10;
          println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
      },
  }

  // structs
  #[allow(dead_code)]
  struct Foo {
      x: (u32, u32),
      y: u32
  }
  let foo = Foo {x: (10, 20), y: 30};
  match foo { 
      Foo { x: (1, b), y: c } =&gt; println!(&quot;b={:?} c={:?}&quot;, b, c),
      Foo {y, ..} =&gt; println!(&quot;y={:?}, others=Don't Care&quot;, y) // match any values
  }

  // Guards
  let pair = (3, 1);
  match pair {
      (x, y) if x == y =&gt; println!(&quot;Twins!&quot;),
      (x, _) if x%2 == 1 =&gt; println!(&quot;The first odd!&quot;),
      _ =&gt; println!(&quot;no correlation ...&quot;)
  }

  // binding to a value with inclusive range
  let num = 3;
  // @1..=10 inclusive range ì‚¬ìš©í•´ì•¼ í•¨
  // exclusive range = @1..10
  match num {
      n @1..=10 =&gt; println!(&quot;num in 1..10 {}&quot;, n),
      n =&gt; println!(&quot;num {}&quot;, n)
  }

  // binding to an enum variant value
  #[allow(dead_code)]
  fn some_number() -&gt; Option&lt;u32&gt; {
      Some(42)
  }
  match some_number() {
      Some(n @ 42) =&gt; println!(&quot;Binding to an enum variant with value {:?}&quot;, n),
      Some(n) =&gt; println!(&quot;Binding to an enum variant {:?}&quot;, n),
      _ =&gt; ()
  }

  // match assign
  let option = Some(10);
  let i = match option {
      Some(i) =&gt; i,
      _ =&gt; panic!(&quot;?&quot;),
  };
  println!(&quot;{}&quot;, i);

  // if let
  let num = Some(7);
  let letter: Option&lt;i32&gt; = None;
  // let emotion: Option&lt;i32&gt; = None;
  if let Some(i) = num {
      println!(&quot;i = {}&quot;, i);
  } else {
      println!(&quot;destructuring failed ...&quot;);
  }

  // match any enum value using if let
  if let None = letter {
      println!(&quot;letter is None&quot;);
  }

  if let Color::Blue = color {
      println!(&quot;Blue&quot;);
  } else if let Color::RGB(x, _, z @1..=100) = color {
      println!(&quot;x={}, z={}&quot;, x, z);
  } else {
      println!(&quot;{:?}&quot;, color);
  }

  // while let
  let mut optional = Some(0);
  while let Some(i) = optional {
      if i &gt; 9 {
          optional = None;
      } else {
          optional = Some(i+ 1);
      }
  }
  optional = Some(0);
  loop { // while letê³¼ ë™ì¼ ë™ì‘
      match optional {
          Some(i) =&gt; {
              if i &gt; 9 {
                  optional = None;
              } else {
                  optional = Some(i+1);
              }
          },
          _ =&gt; break
      }
  }
}
</code></pre>

<h3 id="result-type">Result type</h3>
<p>RustëŠ” result typeì€ ì—´ê±°í˜•(enumerations)ì˜ ì—ëŸ¬ì²˜ë¦¬ ì •ë³´</p>
<p>variants: enumeration data</p>
<pre><code class="rust">// io::Result
pub type Result&lt;T&gt; = Result&lt;T, Error&gt;;

// std::result::Result
Enum std::result::Result
pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>

<h3 id="reference">Reference</h3>
<h3 id="methods">methods</h3>
<p>RustëŠ” ë‹¤ìŒê³¼ ê°™ì´ structì™€ methodë¥¼ ì •ì˜í•œë‹¤.</p>
<pre><code class="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // method definition in implement block
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // Associated Functions
    fn square(size: u32) -&gt; Rectangle {
        Rectangle{
            width: size,
            height: size,
        }
    }
}

fn main() {
    let scale = 2;
    let rect = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    // dbg! return the ownership of the input object
    let rect = dbg!(rect);

    println!(
        &quot;The area of the rectangle {:?} is {} square pixels.&quot;,
        rect,
        rect.area()
    );

    let square = Rectangle::square(100);
    let rect1 = Rectangle { height: 50, width: 30 };
    let rect2 = Rectangle { height: 40, width: 10 };
    let rect3 = Rectangle { height: 45, width: 60 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
    println!(&quot;Can square hold rect1? {}&quot;, square.can_hold(&amp;rect1));
}
</code></pre>

<ul>
<li>The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>.</li>
<li>mutable ì„ ì–¸ì‹œ, <code>&amp;mut self</code>, field ìˆ˜ì • ê°€ëŠ¥</li>
<li>Note that the entire instance must be mutable; Rust doesnâ€™t allow us to mark only certain fields as mutable.</li>
<li>Associated Functionì€ selfê°€ ì—†ëŠ” ê´€ë ¨ í•¨ìˆ˜ (class í•¨ìˆ˜ì™€ ìœ ì‚¬), ìƒì„±ì í•¨ìˆ˜ì— ì£¼ë¡œ ì‚¬ìš©</li>
<li>Associated Functionì€ structì— ëŒ€í•œ namespace syntax(<code>::</code>)ë¡œ ì ‘ê·¼/ì‚¬ìš© ê°€ëŠ¥</li>
<li>ë‹¤ìˆ˜ì˜ impl block ì‚¬ìš© ê°€ëŠ¥</li>
</ul>
<h4 id="field-init-shorthand">Field Init Shorthand</h4>
<p>ìƒì„±í•¨ìˆ˜ì—ì„œ field nameê³¼ function argumentì„ ë™ì¼í•˜ê²Œ ì…ë ¥í•˜ì—¬ ì§§ê²Œ ì“°ëŠ” ë°©ë²•</p>
<pre><code class="rust">fn build_user(email: String, username: String) -&gt; User {
  User {
    email, // field init shorthand
    username,
    active: true,
    sign_in_count: 1,
  }
}
</code></pre>

<h4 id="struct-update-syntax">Struct Update Syntax</h4>
<p>ì•ì„œ ì‚¬ìš©í•œ ì¸ìŠ¤í„´ìŠ¤ì˜ ê°’ì„ ì‚¬ìš©í•´ êµ¬ì¡°ì²´ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•</p>
<pre><code class="rust">fn main() {
  // --snip--
  let user1 = User {
      // init ...
  };

  let user2 = User {
      email: String::from(&quot;another@example.com&quot;),
      ..user1 // user1ì˜ ê°’ìœ¼ë¡œ structure update
  };
}
</code></pre>

<blockquote>
<p>Note that the struct update syntax uses = like an assignment; this is because it moves the data, just as we saw in the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move">â€œWays Variables and Data Interact: Moveâ€</a> section. In this example, we can no longer use user1 after creating user2 because the String in the username field of user1 was moved into user2. The types of active and sign_in_count are types that implement the Copy trait, so the behavior we discussed in the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy">â€œStack-Only Data: Copyâ€</a> section would apply.</p>
</blockquote>
<h3 id="tuple-structs">Tuple Structs</h3>
<ul>
<li>Tupleê³¼ ìœ ì‚¬í•œ êµ¬ì¡°ì²´ë¡œ filed nameì´ ì—†ì´ field typeë§Œì„ ì •ì˜í•œ êµ¬ì¡°ì²´</li>
<li>Named tuple</li>
</ul>
<pre><code class="rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre>

<h2 id="generics">Generics</h2>
<p>Generics is the topic of generalizing types and functionalities to broader cases. This is extremely useful for reducing code duplication in many ways, but can call for rather involved syntax. </p>
<ul>
<li><strong>Generic type</strong>: Generic type parameter <code>&lt;T&gt;</code>ê°€ ì‚¬ìš©ëœ ëª¨ë“  type</li>
<li><strong>Concrete type</strong>: generic type parameterê°€ ì‚¬ìš©ë˜ì§€ ì•Šì€ (typeì´ ëª…ì‹œëœ) ëª¨ë“  type</li>
<li><strong>Generic bounds</strong>: Generic typeì´ ê°€ì ¸ì•¼ í•  typeì˜ íŠ¹ì„±ì„ ê·œì •í•˜ê¸° ìœ„í•´ ì‚¬ìš© <code>&lt;T: Bounds&gt;</code>; ì£¼ë¡œ traitì´ boundë¡œ ì“°ì„ e.g. <code>fn printme&lt;T: std::fmt::Debug&gt; (x: T)</code></li>
<li>It places further constraints on the kind of the Generic types.</li>
<li><code>where</code> can also be used to apply bounds in some cases to be more expressive.</li>
<li><strong>Multiple generic bounds</strong>: Multiple bounds for a single type can be applied with a <code>+</code>. Like normal, different types are separated with <code>,</code>. e.g. <code>fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T)</code></li>
<li><strong>Associated types</strong>: trait genericsì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©ë  typeì„ ì •ì˜í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì´ëŠ” ë°©ë²•</li>
</ul>
<blockquote>
<p>Good Aricle: <a href="https://oswalt.dev/2021/06/using-generic-types-in-rust/">Using Generic Types in Rust</a>
The combination of generics and traits in Rust gives us the same kind of flexibility that we are seeking in a dynamically typed language, but without any of the runtime tradeoffs. </p>
</blockquote>
<h3 id="generic-type">Generic Type</h3>
<pre><code class="rust">struct A; // A concrete type
struct Single(A); // A concrete type; a tuple structure
struct SingleGen&lt;T&gt;(T); // A generic type
let _char: SingleGen&lt;char&gt; = SingleGen('a');
let _t    = SingleGen(A); // Uses `A` defined at the top.
let _i32  = SingleGen(6); // Uses `i32`.
let _char = SingleGen('a'); // Uses `char`.
</code></pre>

<h3 id="generic-functions">Generic functions</h3>
<pre><code class="rust">fn foo&lt;T&gt;(arg: T) { ... }
fn bar(s: SGen&lt;A&gt;) { ... } // not a generic function

generic::&lt;char&gt;(SGen('a')); // call with explicitly specified type parameters
generic(SGen('c')); // call with implicitly specified type parameters
</code></pre>

<h3 id="generic-implementations-generic-methods">Generic Implementations (Generic methods)</h3>
<pre><code class="rust">struct S; // Concrete type `S`
struct GenericVal&lt;T&gt;(T); // Generic type `GenericVal`

// implementation ì„ ì–¸ì‹œ ë‹¤ìŒê³¼ ê°™ì´ íŠ¹ì • typeì„ ëª…ì„¸í•  ìˆ˜ ìˆìŒ
impl GenericVal&lt;f32&gt; {} // Specify `f32`
impl GenericVal&lt;S&gt; {} // Specify `S` as defined above

// `&lt;T&gt;` Must precede the type to remain generic
impl&lt;T&gt; GenericVal&lt;T&gt; {}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

// NewStruct doesn't use any generic types,
// so we don't need to specify any here.
struct NewStruct {}
impl NewStruct {
    // We can still, however, define our own generic parameters
    // on an individual method as desired
    fn x&lt;T&gt;(&amp;self, foo: T) -&gt; T {
        foo
    }
}
</code></pre>

<h3 id="bounds">Bounds</h3>
<h3 id="where-clause">Where clause</h3>
<p>Where clauseëŠ” generic boundì—ì„œ ì„ í–‰ í‘œí˜„ë˜ëŠ” ë³µì¡í•œ type ì •ì˜ë¥¼ í›„ìœ„ì— í‘œí˜„í•˜ì—¬ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì´ëŠ” ë°©ë²•</p>
<pre><code class="rust">// ì„ í–‰ í‘œí˜„
impl&lt;K:Hash+Eq,V&gt; HashMap&lt;K, V&gt; {}

// í›„ìœ„ í‘œí˜„ with where
impl&lt;K,V&gt; HashMap&lt;K, V&gt;
    where K : Hash + Eq {}

impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>

<blockquote>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">Rust RFC for <code>where</code></a></p>
</blockquote>
<h3 id="associated-types">Associated types</h3>
<p>The use of "Associated types" improves the overall readability of code by moving inner types locally into a trait as output types. Syntax for the trait definition is as follows:</p>
<pre><code class="rust">// TRAIT = TRAIT_HEADER '{' TRAIT_ITEM* '}'
// TRAIT_ITEM =
//   ... &lt;existing productions&gt;
//   | 'const' IDENT ':' TYPE [ '=' CONST_EXP ] ';'
//   | 'type' IDENT [ ':' BOUNDS ] [ WHERE_CLAUSE ] [ '=' TYPE ] ';'
//   | 'lifetime' LIFETIME_IDENT ';'

trait Graph {
    type N: Show + Hash;
    type E: Show + Hash;
    ...
}

impl Graph for MyGraph {
    // Both MyNode and MyEdge must implement Show and Hash
    type N = MyNode;
    type E = MyEdge;
    ...
}

fn print_nodes&lt;G: Graph&gt;(g: &amp;G) {
    // here, can assume G::N implements Show
    ...
}
</code></pre>

<p>https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md</p>
<h3 id="phantom-type-parameters">Phantom type parameters</h3>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/phantom-data.html">phantom-data</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/generics/phantom.html">Phantom type parameters</a></li>
</ul>
<h2 id="traits">Traits</h2>
<p>A <code>trait</code> is a collection of methods defined for an unknown type: <code>Self</code>. They can access other methods declared in the same trait. Traits can be implemented for any data type.</p>
<ul>
<li>Derive: </li>
<li><a href="https://doc.rust-lang.org/core/ops/">Operation overloading</a></li>
<li><code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits for types that can be invoked like functions</li>
<li><code>+</code>, <code>+=</code>, <code>-</code>, <code>*</code>, <code>/</code> ... for operator traits</li>
<li><code>Drop</code>: The <code>Drop</code> trait only has one method: <code>drop</code>, which is called automatically when an object goes out of scope.</li>
<li>The main use of the Drop trait is to free the resources that the implementor instance owns.</li>
<li><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code>: the types implemented the <code>Drop</code> trait</li>
<li><code>Iterators</code>: The Iterator trait is used to implement iterators over collections such as arrays.</li>
<li><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code> êµ¬í˜„í•´ì•¼ í•¨</li>
<li>dyn Trait: https://doc.rust-lang.org/rust-by-example/trait/dyn.html</li>
<li>impl Trait: https://doc.rust-lang.org/rust-by-example/trait/impl_trait.html</li>
<li>Copy Trait: í• ë‹¹ì‹œ resource moveê°€ ì•„ë‹Œ copy</li>
<li>Clone Trait: <code>.clone()</code>ìœ¼ë¡œ ëª…ì‹œì ìœ¼ë¡œ copy</li>
<li>Supertraits: Rust doesn't have "inheritance", but you can define a trait as being a superset of another trait.</li>
<li>Disambiguating overlapping traits</li>
<li>https://cotigao.medium.com/dyn-impl-and-trait-objects-rust-fd7280521bea</li>
<li>https://modoocode.com/334</li>
</ul>
<h2 id="to-be-considered">To be considered</h2>
<ul>
<li>Integer Overflow: https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow</li>
<li>ì—­ì°¸ì¡° ê°•ì œ(deref coercion)</li>
</ul>
<h2 id="collections">collections</h2>
<h3 id="box-stack-and-heap">Box, stack and heap</h3>
<p>All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.</p>
<pre><code class="rust">use std::mem;

#[derive(Debug)]
#[allow(dead_code)]
struct Point {
    x: f64,
    y: f64,
}
#[derive(Debug)]
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0f64, y: 0f64 }
}
fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // allocate a point to heap
    return Box::new(Point { x: 0.0, y: 0.0 });
}

// stack allocated variables
let point: Point = origin();
let rectangle: Rectangle = Rectangle {
    top_left: origin(),
    bottom_right: Point { x: 100.0, y: 100.0 },
};
// heap allocated variables
let box_point: Box&lt;Point&gt; = Box::new(origin());
let box_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
    top_left: origin(),
    bottom_right: Point { x: 200.0, y: 200.0 },
});

// inner box in stack
let doubleIndirectBox: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

println!(&quot;{point:?}&quot;);
println!(
    &quot;Point occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;point)
);
println!(
    &quot;Rectangle occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;rectangle)
);

// box size == pointer size
println!(
    &quot;Boxed point occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;box_point)
);
println!(
    &quot;Boxed rectangle occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;box_rectangle)
);
println!(
    &quot;Boxed box occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;doubleIndirectBox)
);

// Copy the data contained in `boxed_point` into `unboxed_point`
let unboxed_point: Point = *box_point;
println!(
    &quot;Unboxed point occupies {} bytes on the stack&quot;,
    mem::size_of_val(&amp;unboxed_point)
);
</code></pre>

<h3 id="string">String</h3>
<ul>
<li><code>to_string()</code>: Display traitì´ êµ¬í˜„ëœ ëª¨ë“  typeì— ì‚¬ìš© ê°€ëŠ¥</li>
<li><code>+</code> ì—°ì‚°ë™ì‘ ì¶”ì²œ X</li>
<li>Stringì˜ index ì ‘ê·¼ ê¸ˆì§€ë¨</li>
<li><code>"à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars()</code>ê³¼ ê°™ì´ ë¬¸ìì†Œ(grapheme)ë¡œ ì ‘ê·¼í•´ì•¼ í•¨</li>
</ul>
<pre><code class="rust">let data = &quot;initial contents&quot;;
let s = data.to_string();
// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
let s = String::from(&quot;initial contents&quot;); // ìœ„ì™€ ë™ì¼

let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);

let mut s = String::from(&quot;lo&quot;);
s.push('l');

let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // s1ì€ ì—¬ê¸°ì„œ ì´ë™ë˜ì–´ ë”ì´ìƒ ì“¸ ìˆ˜ ì—†ìŒì„ ìœ ì˜í•˜ì„¸ìš”

let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);

for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() { // ë¬¸ìì†Œ ë°˜í™˜
    println!(&quot;{}&quot;, c);
}
for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() { // byte ë°˜í™˜
    println!(&quot;{}&quot;, b);
}
</code></pre>

<h3 id="hash-map">hash map</h3>
<h2 id="useful-code-or-crates">Useful code or crates</h2>
<h3 id="read-stdin">Read stdin</h3>
<pre><code class="rust">use std::io;
// ...
// Read a string from stdin
let mut index = String::new();
io::stdin()
    .read_line(&amp;mut index)
    .expect(&quot;Failed to read line&quot;);
let index: usize = index
    .trim()
    .parse()
    .expect(&quot;Index entered was not a number&quot;);

</code></pre>

<h2 id="modules">Modules</h2>
<p>Rust provides a powerful module system that can be used to hierarchically split code in logical units (modules), and manage visibility (public/private) between them.</p>
<p>A module is a collection of items: functions, structs, traits, impl blocks, and even other modules.</p>
<blockquote>
<p>Rustì˜ moduleì´ë€ ì½”ë“œë¥¼ ê³„ì¸µí™”/ì¡°ì§í™” (namespace)í•˜ê³ , pub(public) í‚¤ì›Œë“œë¥¼ í†µí•´ ì½”ë“œì˜ ì ‘ê·¼ì„± ì œì–´í•˜ì—¬, ì½”ë“œì˜ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ê¸° ìœ„í•œ ë°©ë²•</p>
</blockquote>
<pre><code class="rust">mod my_mod { // module my_mod
  pub fn public_func() {
    // ... ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥
  }
  fn private_func() {
    // ... module ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ë¶ˆê°€
    // ... ê°™ì€ module ë‚´ì—ì„  ì ‘ê·¼ ê°€ëŠ¥
  }

  pub mod nested_mod { // module nested_mod
    pub(in crate::my_mod) fn nested_ {
      // ... crate::my_modeì—ì„œë§Œ public function
    }
    pub(self) fn fname {
      // ... pub(self) == private
    }
    pub(super) fn fname {
      // ... parent moduleì—ì„œë§Œ ë³´ì„
    }
  }

  pub(crate) fn public_function_in_crate() {
    // ... ì†í•œ crateì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥
  }
}
</code></pre>

<h2 id="macro">Macro</h2>
<ul>
<li><code>macro_rules</code> allows users to define syntax extension in a declarative way.</li>
<li><code>MacroRule</code> = <code>MacroMatcher =&gt; MacroTranscriber</code>ë¡œ êµ¬ì„±, <code>MacroRule</code>ì€ <code>;</code>ìœ¼ë¡œ êµ¬ë¶„</li>
<li>Each macro by example has a name, and one or more rules. Each rule has two parts: a matcher, describing the syntax that it matches, and a transcriber, describing the syntax that will replace a successfully matched invocation.</li>
<li>Both the matcher and the transcriber must be surrounded by delimiters. Macros can expand to expressions, statements, items (including traits, impls, and foreign items), types, or patterns.</li>
<li><strong>Transcribing</strong>: ì²˜ìŒ matchëœ MacroMatcherì˜ MacroTranscriberë¡œ code ë³€í™˜í•˜ê³  ëª»ì°¾ê±°ë‚˜ ì˜¤ë¥˜ ë°œìƒì‹œ ì¤‘ë‹¨</li>
<li><code>()</code>, <code>[]</code>, <code>{}</code> ëª¨ë“  ê´„í˜¸ëŠ” MacroMatch, MacroRuleì—ì„œ ëª¨ë‘ ì‚¬ìš©ê°€ëŠ¥</li>
</ul>
<blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">macros-by-example</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by example</a></li>
</ul>
</blockquote>
<h2 id="testing">Testing</h2>
<ul>
<li><code>#[test]</code> í•¨ìˆ˜ê°€ testí•¨ìˆ˜ì„ì„ ì„ ì–¸</li>
<li><code>cargo test -- --nocapture --test-threads=1</code></li>
<li><code>cargo test -- -h</code>ìœ¼ë¡œ testing option í™•ì¸í•´ë³´ê¸°</li>
<li><code>cargo test TESTNAME</code>: ë‹¨ì¼ í…ŒìŠ¤íŠ¸ í•­ëª© ì‹¤í–‰</li>
<li><code>cargo test -- --ignored</code>: <code>#[ignore]</code>ë¡œ ì„¤ì •ëœ í…ŒìŠ¤íŠ¸ í•­ëª© í…ŒìŠ¤íŠ¸</li>
<li>unit testëŠ” mod test ë§Œë“¤ê³ , <code>#[cfg(test)]</code> cfg attributeë¥¼ ì„¤ì •í•˜ì—¬ êµ¬ì„±; <code>cargo test</code>ì‹œì—ë§Œ ì»´íŒŒì¼/ì‹¤í–‰</li>
</ul>
<pre><code class="rust">#[derive(Debug, PartialEq, Eq)]
pub struct Rectangle {
  length: u32,
  width: u32,
}

impl Rectangle {
  pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
      self.length &gt; other.length &amp;&amp; self.width &gt; other.width
  }
}

#[allow(dead_code)]
fn add_two(a: i32) -&gt; i32 {
  if a &gt; 100 {
      panic!(&quot;value must be less than or equal to 100.&quot;);
  }
  a + 2
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn larger_can_hold_smaller() {
      let larger = Rectangle { length: 8, width: 7 };
      let smaller = Rectangle { length: 5, width: 1 };

      assert!(larger.can_hold(&amp;smaller), &quot;{:?}&quot;, larger);
  }

  #[test]
  fn smaller_cannot_hold_larger() {
      let larger = Rectangle { length: 8, width: 7 };
      let smaller = Rectangle { length: 5, width: 1 };

      assert!(!smaller.can_hold(&amp;larger), &quot;{:?}&quot;, smaller);
  }

  #[test]
  fn it_adds_two() {
      // assert_eq!ì™€ assert_ne!ëŠ” 
      // ê°ê° ==ê³¼ != ì—°ì‚°ì ì‚¬ìš©í•˜ë¯€ë¡œ
      // PartialEqì™€ Debug íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ í•¨
      assert_eq!(4, add_two(2));
      assert_ne!(4, add_two(3));
  }

  #[test]
  #[should_panic]
  fn greater_than_100() {
      add_two(200);
  }

  #[test]
  #[should_panic(expected = &quot;value must be less than or equal to 100&quot;)]
  fn greater_than_100_2() {
      add_two(200);
  }
}
</code></pre>

<h2 id="rust-attributes">Rust Attributes</h2>
<blockquote>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/attribute.html">rust-by-example</a></li>
<li><a href="https://sjquant.tistory.com/53">sjquant.tistory.com</a></li>
</ul>
</blockquote>
<p>An attribute is <strong>metadata</strong> applied to some <code>module</code>, <code>crate</code> or <code>item</code>. This metadata can be used to/for:</p>
<ul>
<li>conditional compilation of code</li>
<li>set crate name, version and type (binary or library)</li>
<li>disable lints (warnings)</li>
<li>enable compiler features (macros, glob imports, etc.)</li>
<li>link to a foreign library</li>
<li>mark functions as unit tests</li>
<li>mark functions that will be part of a benchmark</li>
</ul>
<h3 id="scope">Scope</h3>
<ul>
<li><code>#![crate_attribute]</code> for a whole crate</li>
<li><code>#[item_attribute]</code>: for a module or item</li>
</ul>
<p>ë‹¤ë¥¸ ë¬¸ì„œì—ì„œëŠ” </p>
<ul>
<li><code>#![Attr]</code>: InnerAttributeë¡œ ì„ ì–¸ëœ ë²”ìœ„ ë‚´ì— ì ìš©</li>
<li><code>#[Attr]</code>: OuterAttributeë¡œ ì„ ì–¸ì´í›„ ì˜¤ëŠ” module, itemì— ì ìš©</li>
</ul>
<h3 id="attribute-arguments">Attribute arguments</h3>
<p>AttributeëŠ” Argumentë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŒ</p>
<ul>
<li><code>#[attribute = "value"]</code></li>
<li><code>#[attribute(key = "value")]</code></li>
<li><code>#[attribute(value)]</code></li>
<li><code>#[attribute(value, value2, value3, value4, value5)]</code></li>
</ul>
<h3 id="frequently-used-attributes">Frequently Used Attributes</h3>
<ul>
<li><code>#[allow(dead_code)]</code>: used to disable linting of the following code block; the compiler option?</li>
<li><code>#![crate_name = "rary"]</code>: The library is named "rary"</li>
<li><code>#![crate_type = "lib"]</code>: This crate is a library; When the crate_type attribute is used, we no longer need to pass the <code>--crate-type</code> flag to rustc.</li>
<li><code>#[cfg(target_os = "linux")]</code> This function only gets compiled if the target OS is linux</li>
<li><code>#[cfg(not(target_os = "linux"))]</code>: And this function only gets compiled if the target OS is <em>not</em> linux</li>
</ul>
<blockquote>
<p>â—<code>cfg!</code>, unlike <code>#[cfg]</code>, it is a <strong>macro</strong> that does not remove any code and only evaluates to true or false.
<code>if cfg!(target_os = "linux") {
  println!("Yes. It's definitely linux!");
} else {
  println!("Yes. It's definitely *not* linux!");
}</code></p>
</blockquote>
<ul>
<li><code>#[test]</code>: used for functional test</li>
<li><code>#[cfg_attr(a, b)]</code>: ë§Œì•½ #[cfg(a)]ë¥¼ ë§Œì¡±í•˜ë©´ #[b] attributeë¥¼ ì ìš©</li>
</ul>
<h3 id="custom-cfg">Custom cfg</h3>
<p>ì‚¬ìš©ì <code>cfg</code>ë„ ë§Œë“¤ ìˆ˜ ìˆìŒ!</p>
<pre><code class="rust">#[cfg(mine)]
fn cond_function() {
    println!(&quot;mine cond!!!&quot;);
}

#[cfg(not(mine))]
fn cond_function() {
    println!(&quot;not mine cond!!!&quot;);
}

fn main() {
   cond_function();
}
</code></pre>

<pre><code class="bash">rustc --cfg mine main.rs &amp;&amp; ./main
RUSTFLAGS='--cfg mine' cargo run
</code></pre>

<h3 id="derive-attribute"><code>derive</code> attribute</h3>
<ul>
<li>íŠ¹ì •í•œ Traitì— ëŒ€í•œ ê¸°ë³¸ì ì¸ êµ¬í˜„(impl)ì„ ê°„í¸í•˜ê²Œ ì œê³µ</li>
<li>ê¸°ë³¸ì ì¸ êµ¬í˜„ì€ ì´ë¯¸ ì •í•´ì ¸ ìˆìœ¼ë©°, ì´ëŸ° Traitì„ derivable í•˜ë‹¤ê³  í•¨</li>
<li>derivable Trait: <code>Eq</code>, <code>PartialEq</code>, <code>Copy</code>, <code>Clone</code>, <code>Debug</code> ...?</li>
</ul>
<pre><code class="rust">#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
</code></pre>

<p>The following is a list of derivable traits:</p>
<ul>
<li>Comparison traits: <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code>.</li>
<li><code>Clone</code>, to create <code>T</code> from <code>&amp;T</code> via a copy.</li>
<li><code>Copy</code>, to give a type 'copy semantics' instead of 'move semantics'.</li>
<li><code>Hash</code>, to compute a hash from <code>&amp;T</code>.</li>
<li><code>Default</code>, to create an empty instance of a data type.</li>
<li><code>Debug</code>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<h2 id="keywords">Keywords</h2>
<h3 id="crate"><code>crate</code></h3>
<pre><code class="rust">
// ì‚¬ìš©í•˜ëŠ” ì™¸ë¶€ crate ì„ ì–¸
extern crate rand;
extern crate my_crate as thing; // the alias of my_crate in my project
extern crate std; // implicitly added to the root of every Rust project

// itemì˜ visibilityë¥¼ í˜„ì¬ crateì— í¬í•¨ëœ moduleë¡œë§Œ í•œì •
pub(crate) enum CoolMarkerType { }

// The root of the current crate
crate::foo::bar
</code></pre>

<h2 id="good-answer-to-understand">Good answer to understand</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self">whats-the-difference-between-self-and-self</a></li>
<li><a href="https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait">Why is the <code>Sized</code> bound necessary in this trait?</a></li>
</ul>
<h2 id="associated-items">Associated items</h2>
<p>This following RFC extends traits with associated items, which make generic programming more convenient, scalable, and powerful. In particular, traits will consist of a set of methods, together with:</p>
<blockquote>
<p>https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md</p>
</blockquote>
<ul>
<li>Associated functions (already present as "static" functions)</li>
<li>Associated consts</li>
<li>Associated types</li>
<li>Associated lifetimes</li>
</ul>
<h2 id="rust-rfc">Rust RFC</h2>
<p>https://github.com/rust-lang/rfcs/tree/master/text</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../python3/" class="btn btn-neutral" title="Python3"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../python3/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
